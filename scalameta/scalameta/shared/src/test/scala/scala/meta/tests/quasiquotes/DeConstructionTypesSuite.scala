package scala.meta.tests
package quasiquotes

import scala.meta._
import scala.meta.dialects.Scala211

/**
  * Validates that construction/deconstruction types are aligned
  */
object DeConstructionTypesSuite {
  val tree: Tree = q"foo"
  tree match {
    case q"${lit: Lit}" => q"${lit: Lit}"
    case q"$qname.this" => q"$qname.this"
    case q"$qname.super" => q"$qname.super"
    case q"super[$qname]" => q"super[$qname]"
    case q"$qname1.super[$qname2]" => q"$qname1.super[$qname2]"
    case q"${name: Term.Name}" => q"${name: Term.Name}"
    case q"$expr.$name" => q"$expr.$name"
    case q"$expr(...$aexprssnel)" => q"$expr(...$aexprssnel)"
    case q"$expr[..$tpesnel]" => q"$expr[..$tpesnel]"
    // case q"$expr1 $name[..$tpes] $expr2" => q"$expr1 $name[..$tpes] $expr2"
    case q"$expr $name[..$tpes] (..$aexprs)" => q"$expr $name[..$tpes] (..$aexprs)"
    case q"!$expr" => q"!$expr"
    case q"~$expr" => q"~$expr"
    case q"-$expr" => q"-$expr"
    case q"+$expr" => q"+$expr"
    case q"$ref = $expr" => q"$ref = $expr"
    case q"$expr1(...$aexprssnel) = $expr2" => q"$expr1(...$aexprssnel) = $expr2"
    case q"return $expr" => q"return $expr"
    case q"throw $expr" => q"throw $expr"
    case q"$expr: $tpe" => q"$expr: $tpe"
    case q"$expr: ..@$annotsnel" => q"$expr: ..@$annotsnel"
    case q"(..$exprsnel)" => q"(..$exprsnel)"
    case q"{ ..$stats }" => q"{ ..$stats }"
    case q"if ($expr1) $expr2 else $expr3" => q"if ($expr1) $expr2 else $expr3"
    case q"$expr match { ..case $casesnel }" => q"$expr match { ..case $casesnel }"
    case q"try $expr catch { ..case $cases } finally $expropt" => q"try $expr catch { ..case $cases } finally $expropt"
    case q"try $expr1 catch $expr2 finally $expropt" => q"try $expr1 catch $expr2 finally $expropt"
    case q"(..$params) => $expr" => q"(..$params) => $expr"
    case q"{ ..case $casesnel }" => q"{ ..case $casesnel }"
    case q"while ($expr1) $expr2" => q"while ($expr1) $expr2"
    case q"do $expr1 while($expr2)" => q"do $expr1 while($expr2)"
    // case q"for (..$enumeratorsnel) $expr" => q"for (..$enumeratorsnel) $expr"
    // case q"for (..$enumeratorsnel) yield $expr" => q"for (..$enumeratorsnel) yield $expr"
    case q"new { ..$stat } with ..$ctorcalls { $param => ..$stats }" => q"new { ..$stat } with ..$ctorcalls { $param => ..$stats }"
    case q"$expr _" => q"$expr _"
    case q"${lit: Lit}" => q"${lit: Lit}"
    case arg"$name = $aexpr" => arg"$name = $aexpr"
    case arg"$expr: _*" => arg"$expr: _*"
    case arg"${expr: Term}" => arg"${expr: Term}"
    case t"${name: Type.Name}" => t"${name: Type.Name}"
    case t"$ref.$tname" => t"$ref.$tname"
    case t"$tpe#$tname" => t"$tpe#$tname"
    case t"$ref.type" => t"$ref.type"
    case t"$tpe[..$tpesnel]" => t"$tpe[..$tpesnel]"
    case t"$tpe1 $tname $tpe2" => t"$tpe1 $tname $tpe2"
    case t"$tpe1 with $tpe2" => t"$tpe1 with $tpe2"
    case t"$tpe1 & $tpe2" => t"$tpe1 & $tpe2"
    case t"$tpe1 | $tpe2" => t"$tpe1 | $tpe2"
    case t"(..$atpes) => $tpe" => t"(..$atpes) => $tpe"
    case t"(..$tpesnel)" => t"(..$tpesnel)"
    case t"$tpeopt { ..$stats }" => t"$tpeopt { ..$stats }"
    case t"$tpe forSome { ..$statsnel }" => t"$tpe forSome { ..$statsnel }"
    case t"$tpe ..@$annotsnel" => t"$tpe ..@$annotsnel"
    case t"_ >: $tpeopt1 <: $tpeopt2" => t"_ >: $tpeopt1 <: $tpeopt2"
    case t"${lit: Lit}" => t"${lit: Lit}"
    case targ"=> $tpe" => targ"=> $tpe"
    case targ"$tpe*" => targ"$tpe*"
    // case targ"$tpe" => targ"$tpe"
    case targ"${tpe: Type}" => targ"${tpe: Type}"
    // case p"$pname" => p"$pname"
    // case q"${name: Pat.Var.Term}" => q"${name: Pat.Var.Term}"
    case p"$pname @ $apat" => p"$pname @ $apat"
    case p"$pat1 | $pat2" => p"$pat1 | $pat2"
    case p"(..$patsnel)" => p"(..$patsnel)"
    case p"$ref[..$tpes](..$apats)" => p"$ref[..$tpes](..$apats)"
    // case p"$pat $name (..$apatsnel)" => p"$pat $name (..$apatsnel)"
    case p"$pat: $ptpe" => p"$pat: $ptpe"
    // case p"$name" => p"$name"
    case p"${name: Term.Name}" => p"${name: Term.Name}"
    case p"$expr.$name" => p"$expr.$name"
    // case p"$lit" => p"$lit"
    case p"${lit: Lit}" => p"${lit: Lit}"
    case p"case $pat if $expropt => $expr" => p"case $pat if $expropt => $expr"
    case parg"${pat: Pat}" => parg"${pat: Pat}"
    case pt"${name: Pat.Var.Type}" => pt"${name: Pat.Var.Type}"
    case pt"$ref.$tname" => pt"$ref.$tname"
    case pt"$ptpe#$tname" => pt"$ptpe#$tname"
    case pt"$ref.type" => pt"$ref.type"
    case pt"$ptpe[..$ptpesnel]" => pt"$ptpe[..$ptpesnel]"
    case pt"$ptpe1 $tname $ptpe2" => pt"$ptpe1 $tname $ptpe2"
    case pt"(..$ptpes) => $ptpe" => pt"(..$ptpes) => $ptpe"
    case pt"(..$ptpesnel)" => pt"(..$ptpesnel)"
    // case pt"..$ptpes { ..$stats }" => pt"..$ptpes { ..$stats }"
    case pt"$ptpe forSome { ..$statsnel }" => pt"$ptpe forSome { ..$statsnel }"
    case pt"$ptpe ..@$annotsnel" => pt"$ptpe ..@$annotsnel"
    case pt"_ >: $tpeopt1 <: $tpeopt2" => pt"_ >: $tpeopt1 <: $tpeopt2"
    case pt"${lit: Lit}" => pt"${lit: Lit}"
    case q"${expr: Term}" => q"${expr: Term}"
    // case q"${member: Member}" => q"${member: Member}"
    case q"import ..$importersnel" => q"import ..$importersnel"
    case q"..$mods val ..$pnamesnel: $tpe" => q"..$mods val ..$pnamesnel: $tpe"
    case q"..$mods var ..$pnamesnel: $tpe" => q"..$mods var ..$pnamesnel: $tpe"
    case q"..$mods def $name[..$tparams](...$paramss): $tpe" => q"..$mods def $name[..$tparams](...$paramss): $tpe"
    case q"..$mods type $tname[..$tparams] >: $tpeopt1 <: $tpeopt2" => q"..$mods type $tname[..$tparams] >: $tpeopt1 <: $tpeopt2"
    // case q"..$mods val ..$patsnel: $tpeopt = $expr" => q"..$mods val ..$patsnel: $tpeopt = $expr"
    // case q"..$mods var ..$patsnel: $tpeopt = $expropt" => q"..$mods var ..$patsnel: $tpeopt = $expropt"
    case q"..$mods def $name[..$tparams](...$paramss): $tpeopt = $expr" => q"..$mods def $name[..$tparams](...$paramss): $tpeopt = $expr"
    case q"..$mods def $name[..$tparams](...$paramss): $tpeopt = macro $expr" => q"..$mods def $name[..$tparams](...$paramss): $tpeopt = macro $expr"
    case q"..$mods type $tname[..$tparams] = $tpe" => q"..$mods type $tname[..$tparams] = $tpe"
    case q"..$mods class $tname[..$tparams] ..$ctorMods (...$paramss) extends $template" => q"..$mods class $tname[..$tparams] ..$ctorMods (...$paramss) extends $template"
    case q"..$mods trait $tname[..$tparams] extends $template" => q"..$mods trait $tname[..$tparams] extends $template"
    case q"..$mods object $name extends $template" => q"..$mods object $name extends $template"
    case q"package object $name extends $template" => q"package object $name extends $template"
    case q"package $ref { ..$stats }" => q"package $ref { ..$stats }"
    case q"..$mods def this(...$paramss)" => q"..$mods def this(...$paramss)"
    case q"..$mods def this(...$paramss) = $expr" => q"..$mods def this(...$paramss) = $expr"
    case param"..$mods $paramname: $atpeopt = $expropt" => param"..$mods $paramname: $atpeopt = $expropt"
    case tparam"..$mods $tparamname[..$tparams] >: $tpeopt1 <: $tpeopt2 <% ..$tpes1 : ..$tpes2" => tparam"..$mods $tparamname[..$tparams] >: $tpeopt1 <: $tpeopt2 <% ..$tpes1 : ..$tpes2"
    case ctor"${ctorname: Ctor.Name}" => ctor"${ctorname: Ctor.Name}"
    case ctor"$ref.$ctorname" => ctor"$ref.$ctorname"
    case ctor"$tpe#$ctorname" => ctor"$tpe#$ctorname"
    case ctor"(..$tpes) => $tpe" => ctor"(..$tpes) => $tpe"
    // case ctor"$ctorname ..@annots" => ctor"$ctorname ..@annots"
    // case ctor"$ctorref(...$aexprssnel)" => ctor"$ctorref(...$aexprssnel)"
    // case ctor"$ctorref[..$atpesnel]" => ctor"$ctorref[..$atpesnel]"
    case template"{ ..$stats1 } with ..$ctorcalls { $param => ..$stats2 }" => template"{ ..$stats1 } with ..$ctorcalls { $param => ..$stats2 }"
    // case mod"@$expr" => mod"@$expr"
    case mod"private[$qname]" => mod"private[$qname]"
    case mod"protected[$qname]" => mod"protected[$qname]"
    case enumerator"$pat <- $expr" => enumerator"$pat <- $expr"
    case enumerator"$pat = $expr" => enumerator"$pat = $expr"
    case enumerator"if $expr" => enumerator"if $expr"
    case importer"$ref.{..$importeesnel}" => importer"$ref.{..$importeesnel}"
    case importee"${iname: Name.Indeterminate}" => importee"${iname: Name.Indeterminate}"
    case importee"$iname1 => $iname2" => importee"$iname1 => $iname2"
    case importee"$iname => _" => importee"$iname => _"
    case source"..$stats" => source"..$stats"
  }
}
